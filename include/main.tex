\chapter{Introduction}
insert motivation here
\section{Goals}

Within this project, we face several sub-questions and -problems:
\begin{enumerate}
    \item How should a user friendly certificate management system look like?
    \item How can we integrate this system in existing workflows to make it as accessible as possible?
    \item How can we manage certificates in an organization?
    \item What challenges are we facing for certificate based authentication on embedded devices?
\end{enumerate}

In the case of this IDP, we have two distinct subprojects to answer those questions: Frontend and backend. In this
document, we focus on issues in the backend and provide answers

\subsubsection*{How should a user friendly certificate management system look like?}
User friendliness is not only a design goal of the frontend, but also the backend. APIs, that are documented and can be
used intuitively. Reduced complexity of setup, deployment and development, for a more user friendly solution for
administrators and future extensions of the program. See sections ORM / dependency management.

\subsubsection*{How can we integrate this system in existing workflows to make it as accessible as possible?}
Deployment of the server as JAVA enterprise application. Java enterprise servers often available in organizations, but
can also be run as standalone. Integration with directory services to streamline the user experience, e.g. single sign
on. Different databases in organizations, provide abstraction from concrete database. See section Design Database
Connection / user management.

\subsubsection*{How can we manage certificates in an organization?}
Certificates have delicate needs. Public certificate should be published by a trusted source, where the private keys
should only be accessible by the user. However, providing a secure way to backup certificates of users is essential to
provide a good user experience. Public stuff in public LDAP. Securely encrypted private keys in local database. See
Certificate Publishing

\subsubsection*{What challenges are we facing for certificate based authentication on embedded devices?}
Embedded devices: Hands-off provisioning of certificates. Fully automated generation and distribution of certificates.
Essentially included in user-friendlyness, since everything can be fully automated in the backend.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Background \& Related Work}
\section{Background: existing certificate management system}

\section{Related work}
maybe Let's Encrypt?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Design}

\section{Database Connection}
currently only mysql, a more generalized approach would be better, e.g. to store data in an oracle database, such as TUM
uses for its TUMonline

Furthermore, mismatches between database schema and java objects are only detected during runtime, which increases
testing overhead. This can be statically checked at compile time, which should decrease bugs and increase developer
productivity

\section{Certificate Exchange}
Currently lacking. Several different methods:
% TODO: cite Valentin Hauner / Beispiel_IDP_2
HKP/SKS for OpenPGP;
LDAP in RFC 4511, 2798 and finally RFC 4519 for the "inetOrgPerson", which contains a "userCertificate";
DANE via the SMIMEA resource record

Most widespread: LDAP, often used in an organization context

\section{REST API}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Implementation}

\section{Object Relational Mapper}
static class generation to check matching models at compile time

\section{Dependency Management \& Build system}
unplanned, but needed due to fragile code base, discovered during initial developement
\subsection{Gradle}
\subsection{Project structure}
\subsection{Outdated Dependency Detection} %
via the gradle-versions-plugin
\subsection{Global Dependency Versioning}
previously problems with updating individual dependencies, since mismatched versions of spring etc. can lead to
"ClassNotFoundException"s at runtime.

via ext version definition, which automatically keep the versions in sync
\subsection{Build Process Automation}
automate creation of database schemas and dfncert dependency via gradle tasks

plus automated generation of a lint report, to catch bugs during development (+ fixing currently existing bugs)

\section{User Management}

\section{Certificate Publishing}
using java openldap. implementation of a RFC 4519 compliant exchange between CMS server and LDAP server

\subsection{}

