\chapter{Introduction}\label{ch:introduction}
insert motivation here
\section{Public-Key Cryptography}\label{sec:publicKeyCryptography}

"key-management problem with symmetric cryptosystems"

"two different keys - one public and the other private"~\cite{schneier2007applied, diffie1976new}

Public key for encryption, private for decryption.
Private key for signature, public key for signature verification.

To solve the problem of man-in-the-middle attacks, a system of trust is established.
In this system a trusted third party verifies, that the public keys are authentic

\section{Public Key Infrastructure}\label{sec:publicKeyInfrastructure}
please refer to rfc3280

\section{Certificates at TUM}\label{sec:certificatesAtTum}

TUM has multiple possible ways of acquiring certificates:

The "Leibniz-Rechenzentrum der Bayerischen Akademie der Wissenschaften" (LRZ in short) offers to sign
certificates~\cite{lrzpki}, which then can be used to secure servers hosted with the LRZ, but also for e-mail security.
The LRZ itself describes the situation as complicated, because of the "many other temporary installed solutions"
("[da] sowohl am LRZ wie auch anderswo provisorische LÃ¶sungen installiert worden sind").

TUM IT-support also offers certification services~\cite{tumZertifikat}.

Additionally, TUMs Faculty of Informatics also runs a registration authority~\cite{inTumCertificates}.

All three of those certification solutions are based on the CA of the Deutsches Forschungsnetz (DFN)~\cite{dfnPki}.
So, in theory any one certification method should have the same "trust", however the certification requirements and
procedures significantly differ.
Furthermore, the process of generating public keys is not handled very well: LRZ provides a guide to generate keys with
the \lstinline{openssl} command line utilities, which disqualifies a lot of the users from using the RA\@.
The Faculty of Informatics generates the keys for their users and stores them secured with a RA generated passphrase.
This fails one of the basic requirements of public-key cryptography, that only the user should ever have access to the
private key.
TUM-IT uses the DFNs webinterface to generate keys, which generates the keys in the users browser and encrypts them with
a user provided passphrase.
This process is a really good compromise between the ability of a layman to generate keys, while not breaking
cryptography guidelines.
However, this webinterface is not very accessible, especially on mobile devices and additionally completely separated
from TUM infrastructure, such that basic integration within TUM workflows or many quality-of-life improvements can't be
made.

\section{Research Questions}\label{sec:researchQuestions}
Within this project, we face several sub-questions and -problems:
\begin{enumerate}
    \item How should a user friendly certificate management system look like?
    \item How can we integrate this system in existing workflows to make it as accessible as possible?
    \item How can we manage certificates in an organization?
    \item What challenges are we facing for certificate based authentication on embedded devices?
\end{enumerate}

In the case of this IDP, we have two distinct subprojects to answer those questions: Frontend and backend.
In this document, we focus on issues in the backend and provide answers

\section{Goals}\label{sec:goals}

\subsubsection*{How should a user friendly certificate management system look like?}
User friendliness is not only a design goal of the frontend, but also the backend APIs, that are documented and can be
used intuitively.
Reduced complexity of setup, deployment and development, for a more user friendly solution for administrators and future
extensions of the program.
See sections ORM / dependency management.

\subsubsection*{How can we integrate this system in existing workflows to make it as accessible as possible?}
Deployment of the server as JAVA enterprise application.
Java enterprise servers often available in organizations, but can also be run as standalone.
Integration with directory services to streamline the user experience, e.g. single sign on.
Different databases in organizations, provide abstraction from concrete database.
See section Design Database Connection / user management.

\subsubsection*{How can we manage certificates in an organization?}
Certificates have delicate needs. Public certificate should be published by a trusted source, where the private keys
should only be accessible by the user. However, providing a secure way to backup certificates of users is essential to
provide a good user experience. Public stuff in public LDAP. Securely encrypted private keys in local database. See
Certificate Publishing

\subsubsection*{What challenges are we facing for certificate based authentication on embedded devices?}
Embedded devices: Hands-off provisioning of certificates. Fully automated generation and distribution of certificates.
Essentially included in user-friendlyness, since everything can be fully automated in the backend.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Background \& Related Work}\label{ch:backgroundRelatedWork}
\section{Email Security}\label{sec:emailSecurity}

Security of emails was not a design goal.
Email with it's several protocols is inherently insecure.
Several approaches to secure email, e.g. SMTP over TLS, which only secures traffic but does not provide end-to-end
security.
Truly confidential and authenticated messages only possible with two competing end-to-end cryptographic implementations:
PGP and S/MIME.

\subsection{PGP}\label{subsec:pgp}

Pretty Good Privacy (PGP) was first implemented by Philip Zimmermann in 1991.
Can be used for encryption and signing of data.
See PGP user's guide.

Software support, e.g. in Mozilla Thunderbird via a plugin: Enigmail

OpenPGP, the modern version and de-facto standardized PGP.
Specified in RFC4880.

\subsection{S/MIME}\label{subsec:s/mime}
see RFC5750

\section{Let's Encrypt}\label{sec:letsEncrypt}

Automatic Certificate Management Environment (ACME) specification in https://tools.ietf.org/html/draft-ietf-acme-acme-08

Already in use by Let's Encrypt. Immensly successful. Maybe draw graph from stats: https://letsencrypt.org/stats/

Not finished, yet. Also: validation challenges aren't end-user focused, but mostly for webservers

X.509 certificates, as issued by Let's Encrypt can be used for email security with S/MIME. However, there's little
previous work to base an organizational integration on.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Design}\label{ch:design}

\begin{figure}
    \centering
%    \includegraphics[width=0.7\textwidth, draft]{figures/system_architecture.pdf}
    \includegraphics[width=\textwidth]{figures/system_architecture.pdf}
    \caption{Architecture of the certificate management system}
    \label{fig:systemArchitecture}
\end{figure}

To solve the questions, we first outline enhancements to the previous implementation and give reasoning, why those
improve the situation w.r.t.\ our research questions.

\section{Database Connection}\label{sec:databaseConnection}
First task, implementing a generic database connection, that works with any database an organization wishes to use.
Previously only MySQL was supported, a more generalized approach would be better, e.g. to store data in an oracle
database, such as TUM uses for its TUMonline.

Furthermore, mismatches between database schema and java objects are only detected during runtime, which increases
testing overhead.
This can be statically checked at compile time, which should decrease bugs and increase developer productivity

\section{Certificate Exchange}\label{sec:certificateExchange}
Currently lacking.
Several different methods~\cite{haunerIdp}:
HKP/SKS for OpenPGP (https://sks-keyservers.net/);
LDAP in RFC 4511, 2798 and finally RFC 4519 for the "inetOrgPerson", which contains a "userCertificate";
DANE via the SMIMEA resource record: RFC7929

Most widespread: LDAP, often used in an organization context

\section{REST API}\label{sec:restApi}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Existing Infrastructure}\label{ch:existingInfrastructure}
\section{Prototype Certificate Management System}\label{sec:existingCertificateManagementSystem}

Dr.\ Wachs et al.\ already implemented a prototype, that can be used to issue and manage certificates.
However, our research questions are completely unanswered by this previous work.
The previous implementation does not integrate into existing organizational structures and thus can't be considered
usable.

\section{TUM LDAP}\label{sec:tumLdap}

\section{TUMonline}\label{sec:tumonline}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Implementation}\label{ch:implementation}

In this chapter, we describe the process of applying the design as described in Chapter~\ref{ch:design} to the
application.

\section{Object Relational Mapper}\label{sec:objectRelationalMapper}
Static class generation to check matching models at compile time.
Using Java Object Oriented Querying (jOOQ), which features an alternative Domain Specific Language (DSL) to SQL.
Provides:
\begin{itemize}
    \item Type safety between the database model and the java application
    \item Support for different databases
    \item Enterprise support if needed for enterprise databases
\end{itemize}

\section{Dependency Management and Build system}\label{sec:dependencyManagementBuildSystem}
Not considered in design specification, i.e. unplanned.
However needed due to fragile code base, discovered during initial developement.

\subsection{Gradle}\label{subsec:gradle}

Previous build automation system with Apache Maven.
Slow build times and unflexible extensibility, which resulted in separate configuration scripts, which needed to be
executed in the right order.
Integration of modern web development frameworks for the frontend also only available for alternative systems, would
result in additional configuration effort.
This should obviously be handled via the build system.
One commonly used modern alternative is Gradle, which we used to reduce the need for separate scripts, since Gradle can
be used to perform arbitrary tasks using the Apache Groovy language.

See https://gradle.org/maven-vs-gradle/
\subsection{Project Structure}\label{subsec:projectStructure}
\subsection{Outdated Dependency Detection}\label{subsec:outdatedDependencyDetection}
Dependency management is a very important
More than 25 different third-party libraries used for this project.
Updating those dependencies is necessary for security updates, especially in a security oriented application, handling
sensitive information of users and responsible to secure certificates.

Outdated dependencies can be detected via the "gradle-versions-plugin", which displays the newest available versions
from open-source repositories.

example output of that plugin?

\subsection{Global Dependency Versioning}\label{subsec:globalDependencyVersioning}
While handling the dependency updates, as described in Subsection~\ref{subsec:outdatedDependencyDetection}, we noticed
problems with updating individual dependencies, since the dependencies have internal dependencies themselves, which is
commonly described as "Dependency Hell": %https://en.wikipedia.org/wiki/Dependency_hell

Especially time consuming and frustrating, since mismatched versions of the Spring Framework and dependent dependencies
can lead to "ClassNotFoundException"s at runtime.
This is inherently due to Javas implementation of lazily loading classes.
(https://docs.oracle.com/javase/specs/jls/se9/jls9.pdf)

There's unfortunately no good solution to this problem.
Our implementation solves this, by specifying version numbers globally.
This couples compatible versions of the Spring Framework and Log4J together which should automatically keep the versions
compatible.
Extensive integration tests are still necessary, however this would be a topic for future work.

\subsection{Build Process Automation}\label{subsec:buildProcessAutomation}
automate creation of database schemas and dfncert dependency via gradle tasks

plus automated generation of a lint report, to catch bugs during development (+ fixing currently existing bugs)

\section{User Management}\label{sec:userManagement}
Using Apache Directory / ApacheDS.


\section{Certificate Publishing}\label{sec:certificatePublishing}
Using Apache Directory / ApacheDS.
Implementation of a RFC 4519 compliant exchange between CMS server and LDAP server

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Conclusion}\label{ch:conclusion}



\section{Future Work}\label{sec:futureWork}

